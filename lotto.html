<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lottery Number Generator</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        /* Custom styles for lottery numbers */
        .number {
            display: inline-block;
            margin: 5px;
            padding: 10px;
            border-radius: 50%;
            color: white;
            width: 50px;
            height: 50px;
            line-height: 30px;
            text-align: center;
            font-size: 20px;
            position: relative;
        }
        /* Black outline for additional balls */
        .additional {
            border: 2px solid black;
        }
        /* Specific styles for yellow balls to ensure legibility */
        .yellow-ball {
            color: black; /* Change text color to black for better contrast */
        }
        
        /* Chaos visualization styles */
        .chaos-indicator {
            display: none;
            margin: 10px 0;
            padding: 15px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            color: white;
            border-radius: 8px;
            text-align: center;
        }
        
        .chaos-progress {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .chaos-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 200% 100%;
            animation: chaosGradient 2s ease-in-out infinite;
            transition: width 0.3s ease;
        }
        
        @keyframes chaosGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .entropy-display {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .entropy-source {
            flex: 1;
            text-align: center;
            padding: 5px;
            margin: 0 2px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        /* Chaos visualization styles */
        .chaos-indicator {
            display: none;
            margin: 10px 0;
            padding: 15px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            color: white;
            border-radius: 8px;
            text-align: center;
        }
        
        .chaos-progress {
            width: 100%;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .chaos-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 200% 100%;
            animation: chaosGradient 2s ease-in-out infinite;
            transition: width 0.3s ease;
        }
        
        @keyframes chaosGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .entropy-display {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .entropy-source {
            flex: 1;
            text-align: center;
            padding: 5px;
            margin: 0 2px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        /* Additional styles for number display enhancement */
    </style>
</head>
<body>
    <div class="container my-5">
        <div class="row">
            <div class="col-md-10 offset-md-1">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h1 class="mb-0">Lottery Number Generator</h1>
                    </div>
                    <div class="card-body">
                        <p>This page generates a set of random numbers for various lotteries and (optionally) checks them against recent draws.
                            The random number generator uses advanced techniques to simulate the chaotic determinism of real lottery draw machines,
                            including physical ball simulation, quantum-inspired algorithms, and multi-entropy fusion methods.
                            Historical data is fetched from the respective lottery's results download page.</p>
                        
                        <div class="alert alert-info">
                            <h5>Random Generation Methods:</h5>
                            <ul class="mb-0">
                                <li><strong>Cryptographic:</strong> Bias-free implementation using Web Cryptography API</li>
                                <li><strong>Multi-Entropy Fusion:</strong> Combines quantum-inspired algorithms, atmospheric chaos simulation, hardware entropy, and high-resolution timing</li>
                                <li><strong>Physical Ball Simulation:</strong> Simulates real lottery machines with ball weight variations, air turbulence, chaos theory (Lorenz attractor), and atmospheric conditions</li>
                                <li><strong>Random.org:</strong> True random numbers from atmospheric noise</li>
                            </ul>
                        </div>
                        <div class="form-group">
                            <label>Random Number Source:</label>
                            <div class="form-check">
                                <input type="radio" class="form-check-input" id="crypto-source" name="random-source" value="crypto" checked>
                                <label class="form-check-label" for="crypto-source">Cryptographic (Unbiased, Local)</label>
                            </div>
                            <div class="form-check">
                                <input type="radio" class="form-check-input" id="multi-entropy-source" name="random-source" value="multi-entropy">
                                <label class="form-check-label" for="multi-entropy-source">Multi-Entropy Fusion (Quantum + Atmospheric + Hardware)</label>
                            </div>
                            <div class="form-check">
                                <input type="radio" class="form-check-input" id="physical-simulation-source" name="random-source" value="physical-simulation">
                                <label class="form-check-label" for="physical-simulation-source">Physical Ball Simulation (Chaos Theory + Weight Variations)</label>
                            </div>
                            <div class="form-check">
                                <input type="radio" class="form-check-input" id="random-org-source" name="random-source" value="random-org">
                                <label class="form-check-label" for="random-org-source">Random.org (Atmospheric Noise, Remote)</label>
                            </div>
                        </div>
                        <!-- Lottery Selection -->
                        <div class="form-group">
                            <label for="lottery-select">Select Lottery:</label>
                            <select class="form-control" id="lottery-select">
                                <option value="UK National Lottery">UK National Lottery</option>
                                <option value="Powerball (USA)">Powerball (USA)</option>
                                <option value="EuroMillions">EuroMillions</option>
                                <option value="Set For Life (UK)">Set For Life (UK)</option>
                                <option value="Custom">Custom</option>
                                <!-- Add more options as needed -->
                            </select>
                        </div>
                        <!-- Number of Balls (Editable for Custom) -->
                        <div class="form-group">
                            <label for="num-balls">Number of Balls:</label>
                            <input type="number" class="form-control" id="num-balls" value="6" min="1" max="20" readonly>
                        </div>
                        <!-- Highest Number (Editable for Custom) -->
                        <div class="form-group">
                            <label for="max-number">Highest Number:</label>
                            <input type="number" class="form-control" id="max-number" value="59" min="1" max="100" readonly>
                        </div>
                        <!-- Additional Balls Configuration -->
                        <div class="form-group form-check">
                            <input type="checkbox" class="form-check-input" id="enable-additional-balls">
                            <label class="form-check-label" for="enable-additional-balls">Enable Additional Balls?</label>
                        </div>
                        <!-- Number of Additional Balls -->
                        <div class="form-group" id="additional-balls-count-group" style="display: none;">
                            <label for="additional-balls-count">Number of Additional Balls:</label>
                            <input type="number" class="form-control" id="additional-balls-count" value="1" min="1" max="5">
                        </div>
                        <!-- Highest Number for Additional Balls -->
                        <div class="form-group" id="additional-balls-max-group" style="display: none;">
                            <label for="additional-balls-max">Highest Number for Additional Balls:</label>
                            <input type="number" class="form-control" id="additional-balls-max" value="26" min="1" max="100">
                        </div>
                        <!-- Fetch Matches Checkbox -->
                        <div class="form-group form-check">
                            <input type="checkbox" class="form-check-input" id="fetch-matches" value="false">
                            <label class="form-check-label" for="fetch-matches">Fetch recent matches?</label>
                        </div>
                        <button id="generate-btn" class="btn btn-primary">Generate</button>
                        
                        <!-- Chaos Visualization -->
                        <div id="chaos-indicator" class="chaos-indicator">
                            <h6>ðŸŽ° Physical Simulation in Progress</h6>
                            <div class="chaos-progress">
                                <div id="chaos-progress-bar" class="chaos-progress-bar" style="width: 0%"></div>
                            </div>
                            <div id="entropy-display" class="entropy-display">
                                <div class="entropy-source">
                                    <div>Quantum</div>
                                    <div id="quantum-entropy">0</div>
                                </div>
                                <div class="entropy-source">
                                    <div>Atmospheric</div>
                                    <div id="atmospheric-entropy">0</div>
                                </div>
                                <div class="entropy-source">
                                    <div>Hardware</div>
                                    <div id="hardware-entropy">0</div>
                                </div>
                                <div class="entropy-source">
                                    <div>Timing</div>
                                    <div id="timing-entropy">0</div>
                                </div>
                            </div>
                            <div id="chaos-status">Initializing ball dynamics...</div>
                        </div>
                        
                        <div class="lottery-numbers-container" id="results">
                            <p id="generated-numbers" class="mt-3"></p>
                            <p id="share-btn" style="display: none;">
                                <button id="share-img-btn" class="btn btn-secondary">Share Image</button>
                            </p>
                            <div id="watermark" style="display: none;">
                                <p>Created using www.kirkbowe.com/lotto.html</p>
                            </div>
                        </div>
                        <div id="save-image" style="display: none;">
                            <button id="save-img-btn" class="btn btn-success">Save Image</button>
                        </div>
                        <div id="matches-container" style="display: none;">
                            <h2 class="mt-4">Best Matches in last 180 days:</h2>
                            <table id="matches-table" class="table table-bordered">
                                <thead>
                                    <tr>
                                        <th>Draw Date</th>
                                        <th>Ball 1</th>
                                        <th>Ball 2</th>
                                        <th>Ball 3</th>
                                        <th>Ball 4</th>
                                        <th>Ball 5</th>
                                        <th>Ball 6</th>
                                        <th>Bonus Ball</th>
                                        <th>Match Count</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="card-footer text-muted">
                        <p>Functionality Â©2024 by <a href="https://www.kirkbowe.com">Kirk Bowe</a>. All rights reserved.</p>
                        <p id="email-address">Contact: shiny.joy9634@fastmail.com</p>
                        <p>Disclaimer: This page is for educational purposes only. Not affiliated with the official Lottery.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Include necessary scripts -->
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
        <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

        <script>
            let lotteries = {};

            // Load lottery configurations from JSON file
            async function loadLotteryConfigurations() {
                try {
                    const response = await fetch('lotteries.json');
                    if (!response.ok) {
                        throw new Error('Failed to load lottery configurations');
                    }
                    lotteries = await response.json();
                    populateLotterySelect();
                } catch (error) {
                    console.error('Error loading lottery configurations:', error);
                }
            }

            // Populate lottery select dropdown
            function populateLotterySelect() {
                const lotterySelect = document.getElementById('lottery-select');
                lotterySelect.innerHTML = ''; // Clear existing options

                for (const lottery in lotteries) {
                    const option = document.createElement('option');
                    option.value = lottery;
                    option.textContent = lottery;
                    lotterySelect.appendChild(option);
                }

                updateFormFields(); // Update form fields based on the first lottery
            }

            let generatorRun = false;
            let isGenerating = false;

            // Event Listeners
            document.getElementById('generate-btn').addEventListener('click', generateAndMatch);
            document.getElementById('save-img-btn').addEventListener('click', async () => {
                console.log('Generating image event...');
                setTimeout(async () => {
                    try {
                        await generateImageFromNumbers();
                        alert('Image saved successfully!');
                    } catch (error) {
                        alert('Failed to save image.');
                    }
                }, 2000);
            });

            // Obfuscate email address
            const emailParts = ['shiny.joy9634', 'fastmail.com'];
            const emailAddress = emailParts[0] + '@' + emailParts[1];
            document.getElementById('email-address').textContent = 'Contact: ' + emailAddress;

            // Colors for number display
            const colors = ['#d00', '#0d0', '#00d', '#dd0', '#0dd', '#d0d', '#f90', '#09f', '#f0f', '#0ff', '#ff0', '#9f0', '#0f9', '#f09', '#90f', '#9ff', '#ff9', '#f9f', '#9f9', '#f99'];

            // Advanced Random Number Generation Methods
            
            // 1. Bias-free cryptographic random number generator
            function getUnbiasedCryptoRandom(min, max) {
                const range = max - min + 1;
                const maxValidValue = Math.floor(0xffffffff / range) * range;
                
                let randomValue;
                do {
                    const bytes = new Uint32Array(1);
                    crypto.getRandomValues(bytes);
                    randomValue = bytes[0];
                } while (randomValue >= maxValidValue);
                
                return (randomValue % range) + min;
            }

            // 2. Atmospheric chaos simulation using multiple entropy sources
            class AtmosphericChaosGenerator {
                constructor() {
                    this.pressureBase = Date.now() % 100000;
                    this.temperatureBase = navigator.hardwareConcurrency || 4;
                    this.humidityBase = screen.width * screen.height;
                }

                generateChaosValue() {
                    const pressure = (this.pressureBase + performance.now()) % 1013;
                    const temperature = (this.temperatureBase + Math.sin(Date.now() / 1000)) * 100;
                    const humidity = (this.humidityBase + Math.cos(Date.now() / 1234)) % 100;
                    
                    return (pressure * temperature * humidity) % 1000000;
                }
            }

            // 3. Physical ball simulation with chaos theory
            class LotteryBallSimulator {
                constructor(ballCount, drawTime = 30000) {
                    this.ballCount = ballCount;
                    this.drawTime = drawTime;
                    this.balls = this.initializeBalls();
                    this.atmosphericGen = new AtmosphericChaosGenerator();
                }

                initializeBalls() {
                    const balls = [];
                    for (let i = 1; i <= this.ballCount; i++) {
                        balls.push({
                            number: i,
                            weight: 1.0 + (getUnbiasedCryptoRandom(-50, 50) / 10000), // Â±0.5% weight variation
                            density: 1.0 + (getUnbiasedCryptoRandom(-30, 30) / 10000),
                            surfaceRoughness: getUnbiasedCryptoRandom(80, 120) / 100,
                            position: {
                                x: Math.random() * 100,
                                y: Math.random() * 100,
                                z: Math.random() * 100
                            },
                            velocity: {
                                x: (Math.random() - 0.5) * 10,
                                y: (Math.random() - 0.5) * 10,
                                z: (Math.random() - 0.5) * 10
                            },
                            exitProbability: 0
                        });
                    }
                    return balls;
                }

                // Simulate Lorenz attractor-style chaotic motion
                simulateChaos(ball, deltaTime, atmosphericFactor) {
                    const sigma = 10.0;
                    const rho = 28.0;
                    const beta = 8.0/3.0;

                    const dx = sigma * (ball.position.y - ball.position.x) * deltaTime * atmosphericFactor;
                    const dy = (ball.position.x * (rho - ball.position.z) - ball.position.y) * deltaTime;
                    const dz = (ball.position.x * ball.position.y - beta * ball.position.z) * deltaTime;

                    ball.position.x += dx;
                    ball.position.y += dy;
                    ball.position.z += dz;

                    // Apply weight and surface roughness effects
                    const weightEffect = 1.0 / ball.weight;
                    const roughnessEffect = ball.surfaceRoughness;
                    
                    ball.exitProbability += (Math.abs(ball.position.x) + Math.abs(ball.position.y) + Math.abs(ball.position.z)) 
                                          * weightEffect * roughnessEffect * deltaTime / 1000;
                }

                // Generate numbers using physical simulation with visual feedback
                async generateDrawNumbers(count) {
                    const drawn = [];
                    const startTime = performance.now();
                    const chaosIndicator = document.getElementById('chaos-indicator');
                    const progressBar = document.getElementById('chaos-progress-bar');
                    const statusDiv = document.getElementById('chaos-status');
                    
                    // Show chaos visualization
                    if (chaosIndicator) {
                        chaosIndicator.style.display = 'block';
                    }
                    
                    let iteration = 0;
                    const maxIterations = 1000;
                    
                    while (drawn.length < count && this.balls.length > 0 && iteration < maxIterations) {
                        const deltaTime = 16.67; // 60fps simulation
                        const atmosphericFactor = this.atmosphericGen.generateChaosValue() / 500000;
                        
                        // Update progress
                        const progress = Math.min((iteration / maxIterations) * 100, 90);
                        if (progressBar) {
                            progressBar.style.width = progress + '%';
                        }
                        
                        // Update status
                        if (statusDiv) {
                            const statusMessages = [
                                'Simulating ball collisions...',
                                'Calculating air turbulence effects...',
                                'Applying Lorenz attractor dynamics...',
                                'Processing atmospheric chaos...',
                                'Computing weight variations...',
                                'Analyzing exit probabilities...',
                                'Simulating mechanical friction...',
                                'Modeling temperature effects...'
                            ];
                            statusDiv.textContent = statusMessages[iteration % statusMessages.length];
                        }
                        
                        // Simulate all balls
                        this.balls.forEach(ball => {
                            this.simulateChaos(ball, deltaTime, atmosphericFactor);
                        });

                        // Check for ball exits based on probability
                        this.balls.sort((a, b) => b.exitProbability - a.exitProbability);
                        
                        if (this.balls[0].exitProbability > Math.random() * 100) {
                            drawn.push(this.balls[0].number);
                            this.balls.splice(0, 1);
                            
                            if (statusDiv) {
                                statusDiv.textContent = `Ball ${drawn[drawn.length - 1]} selected! (${drawn.length}/${count})`;
                            }
                            
                            // Add small delay to simulate real draw timing
                            await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 300));
                        }

                        iteration++;
                        
                        // Small delay for visual feedback
                        if (iteration % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }

                    // Complete progress
                    if (progressBar) {
                        progressBar.style.width = '100%';
                    }
                    if (statusDiv) {
                        statusDiv.textContent = 'Physical simulation complete!';
                    }

                    // Fill remaining with fallback if needed
                    while (drawn.length < count && this.balls.length > 0) {
                        const randomIndex = getUnbiasedCryptoRandom(0, this.balls.length - 1);
                        drawn.push(this.balls[randomIndex].number);
                        this.balls.splice(randomIndex, 1);
                    }

                    // Hide chaos indicator after a delay
                    setTimeout(() => {
                        if (chaosIndicator) {
                            chaosIndicator.style.display = 'none';
                        }
                    }, 2000);

                    return drawn.sort((a, b) => a - b);
                }
            }

            // 4. Quantum-inspired random number generator
            class QuantumInspiredRNG {
                constructor() {
                    this.quantumState = new Array(8).fill(0).map(() => Math.random());
                }

                // Simulate quantum superposition collapse
                generateQuantumNumber(min, max) {
                    // Simulate wave function collapse using multiple measurements
                    let measurements = [];
                    for (let i = 0; i < 8; i++) {
                        const measurement = this.quantumState[i] * getUnbiasedCryptoRandom(0, 1000000);
                        measurements.push(measurement);
                    }

                    // Apply quantum interference patterns
                    const interference = measurements.reduce((acc, val, idx) => {
                        return acc + val * Math.cos(idx * Math.PI / 4);
                    }, 0);

                    // Normalize and map to range
                    const normalized = Math.abs(interference) % 1000000;
                    return Math.floor((normalized / 1000000) * (max - min + 1)) + min;
                }

                // Update quantum state (decoherence simulation)
                updateQuantumState() {
                    this.quantumState = this.quantumState.map(state => {
                        return (state + Math.random() - 0.5) % 1;
                    });
                }
            }

            // 5. Multiple entropy source combiner
            class MultiEntropyRNG {
                constructor() {
                    this.quantumRNG = new QuantumInspiredRNG();
                    this.atmosphericGen = new AtmosphericChaosGenerator();
                }

                async generateNumber(min, max) {
                    // Update entropy displays
                    this.updateEntropyDisplay();
                    
                    const sources = await Promise.all([
                        this.getCryptoSource(min, max),
                        this.getQuantumSource(min, max),
                        this.getAtmosphericSource(min, max),
                        this.getTimingSource(min, max),
                        this.getHardwareSource(min, max)
                    ]);

                    // Combine using XOR and weighted average
                    let combined = 0;
                    sources.forEach((source, idx) => {
                        combined ^= source << idx;
                    });

                    const weightedAvg = sources.reduce((sum, val, idx) => {
                        const weight = [0.3, 0.25, 0.2, 0.15, 0.1][idx];
                        return sum + (val * weight);
                    }, 0);

                    const finalValue = Math.abs(combined ^ Math.floor(weightedAvg)) % (max - min + 1);
                    return finalValue + min;
                }

                updateEntropyDisplay() {
                    const quantumDiv = document.getElementById('quantum-entropy');
                    const atmosphericDiv = document.getElementById('atmospheric-entropy');
                    const hardwareDiv = document.getElementById('hardware-entropy');
                    const timingDiv = document.getElementById('timing-entropy');

                    if (quantumDiv) {
                        quantumDiv.textContent = Math.floor(Math.random() * 1000);
                    }
                    if (atmosphericDiv) {
                        atmosphericDiv.textContent = Math.floor(this.atmosphericGen.generateChaosValue() / 1000);
                    }
                    if (hardwareDiv) {
                        hardwareDiv.textContent = Math.floor((navigator.hardwareConcurrency || 4) * Math.random() * 100);
                    }
                    if (timingDiv) {
                        timingDiv.textContent = Math.floor(performance.now() % 1000);
                    }
                }

                async getCryptoSource(min, max) {
                    return getUnbiasedCryptoRandom(min, max);
                }

                getQuantumSource(min, max) {
                    this.quantumRNG.updateQuantumState();
                    return this.quantumRNG.generateQuantumNumber(min, max);
                }

                getAtmosphericSource(min, max) {
                    const chaos = this.atmosphericGen.generateChaosValue();
                    return (chaos % (max - min + 1)) + min;
                }

                getTimingSource(min, max) {
                    const highResTiming = performance.now() * 1000000;
                    return Math.floor(highResTiming % (max - min + 1)) + min;
                }

                getHardwareSource(min, max) {
                    const hardware = navigator.hardwareConcurrency * navigator.deviceMemory * screen.pixelDepth;
                    return Math.floor(hardware % (max - min + 1)) + min;
                }
            }

            // Function to get a random number using Web Cryptography API
            function getCryptoRandom(min, max) {
                const range = max - min + 1;
                const bytes = new Uint32Array(1);
                crypto.getRandomValues(bytes);
                return Math.floor(bytes[0] / 0xffffffff * range) + min;
            }

            // Enhanced random number generation with multiple methods
            const multiEntropyRNG = new MultiEntropyRNG();

            // Updated function to get random number based on selected source
            async function getRandomNumber(min, max) {
                const source = document.querySelector('input[name="random-source"]:checked').value;
                
                if (source === 'random-org') {
                    try {
                        const response = await fetch(`https://www.random.org/integers/?num=1&min=${min}&max=${max}&col=1&base=10&format=plain&rnd=new`);
                        if (!response.ok) {
                            throw new Error('Failed to fetch from Random.org');
                        }
                        const number = await response.text();
                        return parseInt(number.trim(), 10);
                    } catch (error) {
                        console.error('Random.org fetch failed, falling back to Multi-Entropy RNG:', error);
                        return await multiEntropyRNG.generateNumber(min, max);
                    }
                } else if (source === 'physical-simulation') {
                    // Use physical ball simulation for ultimate realism
                    const simulator = new LotteryBallSimulator(max);
                    const results = await simulator.generateDrawNumbers(1);
                    return results[0] || getUnbiasedCryptoRandom(min, max);
                } else if (source === 'multi-entropy') {
                    return await multiEntropyRNG.generateNumber(min, max);
                } else {
                    return getUnbiasedCryptoRandom(min, max);
                }
            }

            // Function to generate random numbers based on selected lottery
            async function generateRandomNumbers() {
                const lottery = document.getElementById('lottery-select').value;
                const source = document.querySelector('input[name="random-source"]:checked').value;
                let config;

                if (lottery === "Custom") {
                    const numBalls = parseInt(document.getElementById('num-balls').value, 10);
                    const maxNumber = parseInt(document.getElementById('max-number').value, 10);
                    const enableAdditional = document.getElementById('enable-additional-balls').checked;
                    let additionalBalls = null;

                    if (enableAdditional) {
                        const numAdditional = parseInt(document.getElementById('additional-balls-count').value, 10);
                        const maxAdditional = parseInt(document.getElementById('additional-balls-max').value, 10);
                        additionalBalls = { num: numAdditional, maxNumber: maxAdditional };
                    }

                    config = {
                        numBalls: numBalls,
                        maxNumber: maxNumber,
                        additionalBalls: additionalBalls,
                        historicalDataUrl: ''
                    };
                } else {
                    config = lotteries[lottery];
                }

                let drawnNumbers = [];

                // Use physical simulation for main numbers if selected
                if (source === 'physical-simulation') {
                    const simulator = new LotteryBallSimulator(config.maxNumber);
                    drawnNumbers = await simulator.generateDrawNumbers(config.numBalls);
                } else {
                    // Traditional method with enhanced RNG
                    let availableNumbers = Array.from({ length: config.maxNumber }, (_, i) => i + 1);

                    // Draw main numbers
                    for (let i = 0; i < config.numBalls; i++) {
                        const randomIndex = await getRandomNumber(0, availableNumbers.length - 1);
                        const drawnNumber = availableNumbers[randomIndex];
                        drawnNumbers.push(drawnNumber);
                        // Remove the drawn number from available pool
                        availableNumbers.splice(randomIndex, 1);
                    }

                    // Sort main numbers
                    drawnNumbers.sort((a, b) => a - b);
                }

                // Handle additional balls if applicable
                if (config.additionalBalls) {
                    if (source === 'physical-simulation') {
                        // Separate simulation for additional balls
                        const additionalSimulator = new LotteryBallSimulator(config.additionalBalls.maxNumber);
                        const additionalResults = await additionalSimulator.generateDrawNumbers(config.additionalBalls.num);
                        drawnNumbers.push(...additionalResults);
                    } else {
                        // Reset available numbers pool for additional balls if they use a different range
                        let availableNumbers;
                        if (config.additionalBalls.maxNumber !== config.maxNumber) {
                            availableNumbers = Array.from(
                                { length: config.additionalBalls.maxNumber }, 
                                (_, i) => i + 1
                            );
                        } else {
                            // Remove already drawn main numbers from additional ball pool
                            availableNumbers = Array.from(
                                { length: config.additionalBalls.maxNumber }, 
                                (_, i) => i + 1
                            ).filter(num => !drawnNumbers.includes(num));
                        }
                        
                        for (let i = 0; i < config.additionalBalls.num; i++) {
                            const randomIndex = await getRandomNumber(0, availableNumbers.length - 1);
                            const drawnNumber = availableNumbers[randomIndex];
                            drawnNumbers.push(drawnNumber);
                            // Remove the drawn number from available pool
                            availableNumbers.splice(randomIndex, 1);
                        }
                    }
                }

                return drawnNumbers;
            }

            // Fetch historical data
            async function fetchHistoricalData(url) {
                const response = await fetch(`https://corsproxy.io/?${url}`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const csvText = await response.text();
                return csvText;
            }

            // Parse CSV data
            function parseCSV(csvText, lottery) {
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                const rows = lines.slice(1).map(line => line.split(','));
                

                const config = lotteries[lottery];
                const numBalls = config.numBalls;
                const additionalBalls = config.additionalBalls ? config.additionalBalls.num : 0;

                rows.forEach(row => row.length = 1 + numBalls + additionalBalls);

                return { headers, rows };
            }

            // Find best matches
            function findBestMatches(generatedNumbers, historicalData, lottery) {
                const { headers, rows } = historicalData;
                const matches = rows.map(row => {
                    let balls = [];
                    let additionalBalls = [];
                    let matchCount = 0;

                    const config = lotteries[lottery];
                    const numBalls = config.numBalls;
                    const additionalBallsConfig = config.additionalBalls;

                    balls = row.slice(1, 1 + numBalls).map(Number);

                    if (additionalBallsConfig) {
                        additionalBalls = row.slice(1 + numBalls, 1 + numBalls + additionalBallsConfig.num).map(Number);
                    }

                    matchCount = balls.filter(ball => generatedNumbers.includes(ball)).length;
                    matchCount += additionalBalls.filter(ball => generatedNumbers.includes(ball)).length;

                    return { row, matchCount };
                });

                matches.sort((a, b) => b.matchCount - a.matchCount);
                return matches.slice(0, 10);
            }

            // Display numbers one by one with animation
            function displayNumbersOneByOne(numbers) {
                const numbersContainer = document.getElementById('generated-numbers');
                numbersContainer.innerHTML = ''; // Clear existing content

                let index = 0;
                const interval = setInterval(() => {
                    if (index < numbers.length) {
                        const numberSpan = document.createElement('span');
                        const currentNumber = numbers[index];
                        
                        // Check if the number is an additional ball
                        const isAdditional = typeof currentNumber === 'string' && 
                            (currentNumber.startsWith('Powerball') || 
                             currentNumber.startsWith('Lucky') || 
                             currentNumber.startsWith('Life Ball') ||
                             currentNumber.startsWith('Bonus Ball'));
        
                        numberSpan.textContent = currentNumber;
                        numberSpan.classList.add('number');
                        
                        // Assign random background color
                        const bgColor = colors[Math.floor(Math.random() * colors.length)];
                        numberSpan.style.backgroundColor = bgColor;

                        // Adjust text color for better contrast (specifically for yellow balls)
                        if (['#dd0', '#f90', '#ff0'].includes(bgColor)) { // Add other yellowish colors if needed
                            numberSpan.classList.add('yellow-ball');
                        }

                        // Add black outline if it's an additional ball
                        if (isAdditional) {
                            numberSpan.classList.add('additional');
                        }

                        numbersContainer.appendChild(numberSpan);
                        index++;
                    } else {
                        isGenerating = false;
                        document.getElementById('generate-btn').disabled = false;
                        document.getElementById('save-image').style.display = 'inherit';
                        document.getElementById('watermark').style.display = 'inherit';
                        clearInterval(interval); // Stop the interval
                    }
                }, 500); // Adjust delay as needed
            }

            // Generate image from numbers using html2canvas
            async function generateImageFromNumbers() {
                const numbersContainer = document.getElementById('results');

                if (!numbersContainer) {
                    console.error('Container element not found');
                    throw new Error('Container element not found');
                }

                const canvas = await html2canvas(numbersContainer, {
                    allowTaint: true,
                    useCORS: true,
                    logging: false,
                    scale: window.devicePixelRatio
                });

                const imgData = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = imgData;
                const dateString = new Date().toISOString().slice(0, 10);
                link.download = `lottery-numbers-${dateString}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // Generate Twitter share link
            function generateTwitterShareLink() {
                const baseUrl = 'https://twitter.com/intent/tweet';
                const text = 'Check out my lottery numbers!';
                const url = window.location.href;
                const hashTags = 'lottery,numbers';
                const params = new URLSearchParams({
                    text: `${text} ${url}`,
                    url,
                    hashtags: hashTags,
                    via: 'your_twitter_handle', // Optional
                });

                return `${baseUrl}?${params.toString()}&media=clipboard:`;
            }

            // Update form fields based on selected lottery
            document.getElementById('lottery-select').addEventListener('change', updateFormFields);

            // Toggle additional balls configuration based on checkbox
            document.getElementById('enable-additional-balls').addEventListener('change', function() {
                const isChecked = this.checked;
                document.getElementById('additional-balls-count-group').style.display = isChecked ? 'block' : 'none';
                document.getElementById('additional-balls-max-group').style.display = isChecked ? 'block' : 'none';
            });

            function updateFormFields() {
                const lottery = document.getElementById('lottery-select').value;
                const config = lotteries[lottery];
                const numBallsInput = document.getElementById('num-balls');
                const maxNumberInput = document.getElementById('max-number');
                const enableAdditionalBallsCheckbox = document.getElementById('enable-additional-balls');
                const fetchMatchesCheckbox = document.getElementById('fetch-matches');

                if (lottery === "Custom") {
                    // Make inputs editable
                    numBallsInput.readOnly = false;
                    maxNumberInput.readOnly = false;

                    // Reset values to defaults or leave as user set
                    // Optionally, you can set placeholders or retain current values

                    // Show or hide additional balls configuration based on current state
                    const isChecked = enableAdditionalBallsCheckbox.checked;
                    document.getElementById('additional-balls-count-group').style.display = isChecked ? 'block' : 'none';
                    document.getElementById('additional-balls-max-group').style.display = isChecked ? 'block' : 'none';

                    // Disable fetch matches checkbox for custom lottery
                    fetchMatchesCheckbox.checked = false;
                    fetchMatchesCheckbox.disabled = true;
                } else {
                    // Make inputs read-only and set to predefined values
                    numBallsInput.readOnly = true;
                    maxNumberInput.readOnly = true;

                    numBallsInput.value = config.numBalls;
                    maxNumberInput.value = config.maxNumber;

                    // Handle additional balls
                    if (config.additionalBalls) {
                        enableAdditionalBallsCheckbox.checked = true;
                        document.getElementById('additional-balls-count-group').style.display = 'block';
                        document.getElementById('additional-balls-max-group').style.display = 'block';
                        document.getElementById('additional-balls-count').value = config.additionalBalls.num;
                        document.getElementById('additional-balls-max').value = config.additionalBalls.maxNumber;
                    } else {
                        enableAdditionalBallsCheckbox.checked = false;
                        document.getElementById('additional-balls-count-group').style.display = 'none';
                        document.getElementById('additional-balls-max-group').style.display = 'none';
                        document.getElementById('additional-balls-count').value = 1;
                        document.getElementById('additional-balls-max').value = 26;
                    }

                    // Enable or disable fetch matches checkbox based on historicalDataUrl
                    if (config.historicalDataUrl) {
                        fetchMatchesCheckbox.disabled = false;
                    } else {
                        fetchMatchesCheckbox.checked = false;
                        fetchMatchesCheckbox.disabled = true;
                    }
                }

                // Adjust the table headers if needed
                adjustTableHeaders(lottery);
            }

            // Initialize form fields on page load
            window.addEventListener('DOMContentLoaded', () => {
                loadLotteryConfigurations();
            });

            // Main function to generate numbers and fetch matches
            async function generateAndMatch() {
                if (isGenerating) {
                    return; // Exit if already generating
                }

                document.getElementById('generate-btn').disabled = true;
                isGenerating = true;

                // Clear previous results
                document.getElementById('generated-numbers').innerHTML = '';
                document.getElementById('matches-container').style.display = 'none';

                const lottery = document.getElementById('lottery-select').value;
                const randomNumbers = await generateRandomNumbers(); // Add await here
                displayNumbersOneByOne(randomNumbers);

                // Only fetch historical data if checkbox is checked and not Custom lottery
                if (lottery === "Custom" || !document.getElementById('fetch-matches').checked) {
                    isGenerating = false;
                    document.getElementById('generate-btn').disabled = false;
                    return;
                }

                const config = lotteries[lottery];

                // Skip if historical data URL is not available
                if (!config.historicalDataUrl) {
                    isGenerating = false;
                    document.getElementById('generate-btn').disabled = false;
                    return;
                }

                try {
                    const csvText = await fetchHistoricalData(config.historicalDataUrl);
                    const historicalData = parseCSV(csvText, lottery);
                    const bestMatches = findBestMatches(randomNumbers, historicalData, lottery);

                    const tbody = document.getElementById('matches-table').querySelector('tbody');
                    tbody.innerHTML = '';

                    bestMatches.forEach(({ row, matchCount }) => {
                        const tr = document.createElement('tr');
                        row.forEach(cell => {
                            const td = document.createElement('td');
                            td.textContent = cell;
                            tr.appendChild(td);
                        });
                        const tdMatchCount = document.createElement('td');
                        tdMatchCount.textContent = matchCount;
                        tr.appendChild(tdMatchCount);
                        tbody.appendChild(tr);
                    });

                    // Adjust table headers based on lottery
                    adjustTableHeaders(lottery);

                    // Show the matches table
                    document.getElementById('matches-container').style.display = 'block';
                } catch (error) {
                    console.error('Error fetching or processing historical data:', error);
                    alert('Failed to fetch historical data. Please try again later.');
                } finally {
                    isGenerating = false;
                    document.getElementById('generate-btn').disabled = false;
                }
            }

            // Adjust table headers based on lottery
            function adjustTableHeaders(lottery) {
                const table = document.getElementById('matches-table');
                const thead = table.querySelector('thead tr');
                thead.innerHTML = ''; // Clear existing headers

                let headers = ['Draw Date'];

                const config = lotteries[lottery] || {};

                // Determine number of main balls
                const numBalls = (lottery === "Custom") ? parseInt(document.getElementById('num-balls').value, 10) : config.numBalls;

                for (let i = 1; i <= numBalls; i++) {
                    headers.push(`Ball ${i}`);
                }

                // Determine if there are additional balls
                let additionalBallsConfig = null;
                if (lottery === "Custom") {
                    if (document.getElementById('enable-additional-balls').checked) {
                        const numAdditional = parseInt(document.getElementById('additional-balls-count').value, 10);
                        const maxAdditional = parseInt(document.getElementById('additional-balls-max').value, 10);
                        additionalBallsConfig = { num: numAdditional, maxNumber: maxAdditional };
                    }
                } else {
                    additionalBallsConfig = config.additionalBalls;
                }

                if (additionalBallsConfig) {
                    for (let i = 1; i <= additionalBallsConfig.num; i++) {
                        // Determine label based on known lotteries
                        let label = `Additional Ball ${i}`;
                        if (lottery === "Powerball (USA)") {
                            label = `Powerball`;
                        } else if (lottery === "EuroMillions") {
                            label = `Lucky Star ${i}`;
                        } else if (lottery === "Set For Life (UK)") {
                            label = `Life Ball`;
                        }
                        headers.push(label);
                    }
                }

                headers.push('Match Count');

                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    thead.appendChild(th);
                });
            }

            // ReCaptcha related functions (if needed)
            function renderReCaptcha() {
                grecaptcha.ready(function() {
                  grecaptcha.execute('YOUR_RECAPTCHA_SITE_KEY', { action: 'submit' }).then(function(token) {
                    validateReCaptcha(token);
                  });
                });
            }

            function validateReCaptcha(token) {
                fetch('https://www.google.com/recaptcha/api/siteverify', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: `secret=YOUR_RECAPTCHA_SECRET_KEY&response=${token}`
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        generateAndMatch();
                    } else {
                        alert('reCAPTCHA validation failed. Please try again.');
                    }
                })
                .catch(error => {
                    console.error('Error validating reCAPTCHA:', error);
                    alert('reCAPTCHA validation failed. Please try again.');
                });
            }
        </script>
        <!-- Optional: Include Cloudflare beacon or other scripts as needed -->
    </body>
</html>
